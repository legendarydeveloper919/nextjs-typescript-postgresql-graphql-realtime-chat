import Fastify from "fastify";
import axios from "axios";
import { {{ modelImports }} } from "./models"
import {HooksConfiguration} from "@wundergraph/sdk/dist/configure";

declare module "fastify" {
    interface FastifyRequest {
        /**
         * Coming soon!
         */
        ctx: Context;
    }
}

export interface Context {
    user?: User;
}

export interface User {
    provider?: string;
    provider_id?: string;
    email?: string;
    email_verified?: boolean;
    name?: string;
    first_name?: string;
    last_name?: string;
    nick_name?: string;
    description?: string;
    user_id?: string;
    avatar_url?: string;
    location?: string;
    roles?: Role[];
}

export type Role = {{{ roleDefinitions }}};

export type AuthenticationResponse = AuthenticationOK | AuthenticationDeny;

export interface AuthenticationOK {
    status: "ok";
    user: User;
    message?: never;
}

export interface AuthenticationDeny {
    status: "deny";
    user?: never;
    message?: string;
}

const internalClientAuthorizationHeader = "Bearer {{internalClientBearerToken}}"

const internalRequest = async (operationName: string, input?: any): Promise<any> => {
    const url = "http://localhost:9991/internal/api/main/operations/" + operationName;
    const res = await axios.post(url, JSON.stringify(input || {}), {
        headers: {
            "Content-Type": "application/json",
            Authorization: internalClientAuthorizationHeader,
        },
    });
    return res.data;
};

interface InternalClient {
    {{#if hasInternalQueries}}
    queries: {
        {{#each internalQueries}}
            {{operationName}}: ({{#if hasInternalInput}}input: Internal{{operationName}}Input{{/if}}) => Promise<{{operationName}}Response>;
        {{/each}}
    };
    {{/if}}
    {{#if hasInternalMutations}}
        mutations: {
        {{#each internalMutations}}
            {{operationName}}: ({{#if hasInternalInput}}input: Internal{{operationName}}Input{{/if}}) => Promise<{{operationName}}Response>;
        {{/each}}
        };
    {{/if}}
}

const client = {
    {{#if hasInternalQueries}}
        queries: {
        {{#each internalQueries}}
            {{operationName}}: async ({{#if hasInternalInput}}input: Internal{{operationName}}Input{{/if}}) => internalRequest("{{operationName}}"{{#if hasInternalInput}},input{{/if}}),
        {{/each}}
        },
    {{/if}}
    {{#if hasInternalMutations}}
        mutations: {
        {{#each internalMutations}}
            {{operationName}}: async ({{#if hasInternalInput}}input: Internal{{operationName}}Input{{/if}}) => internalRequest("{{operationName}}"{{#if hasInternalInput}},input{{/if}}),
        {{/each}}
        },
    {{/if}}
}

// configureWunderGraphHooksWithClient configures the WunderGraph hooks with an injected client
// the client exposes all Operations, allowing you to implement side effects
// more info on how to use hooks can be found here: https://wundergraph.com/docs/overview/features/typesafe_hooks
// hooks reference docs: https://wundergraph.com/docs/reference/wundergraph_config_ts/overview
export const configureWunderGraphHooksWithClient = (config: (client: InternalClient) => HooksConfig) => configureWunderGraphHooks(config(client));

export interface HooksConfig {
    authentication?: {
        postAuthentication?: (user: User) => Promise<void>;
        mutatingPostAuthentication?: (user: User) => Promise<AuthenticationResponse>;
        revalidate?: (user: User) => Promise<AuthenticationResponse>;
    };
{{#if hasQueries}}
    queries?: {
    {{#each queries}}
        {{operationName}}?: {
            mockResolve?: ({{#if hasInternalInput}}ctx: Context, input: Injected{{operationName}}Input{{else}}ctx: Context{{/if}}) => Promise<{{operationName}}Response>;
            preResolve?: ({{#if hasInternalInput}}ctx: Context, input: Injected{{operationName}}Input{{else}}ctx: Context{{/if}}) => Promise<void>;{{#if hasInternalInput}}
            mutatingPreResolve?: (ctx: Context, input: Injected{{operationName}}Input) => Promise<Injected{{operationName}}Input>;{{/if}}
            postResolve?: (ctx: Context{{#if hasInternalInput}}, input: Injected{{operationName}}Input{{/if}},response: {{operationName}}Response) => Promise<void>;
            mutatingPostResolve?: ({{#if hasInternalInput}}ctx: Context, input: Injected{{operationName}}Input{{else}}ctx: Context{{/if}}, response: {{operationName}}Response) => Promise<{{operationName}}Response>;
        }
    {{/each}}
    };
{{else}}
    queries?: {};
{{/if}}
{{#if hasMutations}}
    mutations?: {
        {{#each mutations}}
            {{operationName}}?: {
                mockResolve?: ({{#if hasInternalInput}}ctx: Context, input: Injected{{operationName}}Input{{else}}ctx: Context{{/if}}) => Promise<{{operationName}}Response>;
                preResolve?: ({{#if hasInternalInput}}ctx: Context, input: Injected{{operationName}}Input{{else}}ctx: Context{{/if}}) => Promise<void>;{{#if hasInternalInput}}
                mutatingPreResolve?: (ctx: Context{{#if hasInternalInput}}, input: Injected{{operationName}}Input{{/if}}) => Promise<Injected{{operationName}}Input>;{{/if}}
                postResolve?: (ctx: Context{{#if hasInternalInput}}, input: Injected{{operationName}}Input{{/if}}, response: {{operationName}}Response) => Promise<void>;
                mutatingPostResolve?: ({{#if hasInternalInput}}ctx: Context, input: Injected{{operationName}}Input{{else}}ctx: Context{{/if}}, response: {{operationName}}Response) => Promise<{{operationName}}Response>;
            }
        {{/each}}
    };
{{else}}
    mutations?: {};
{{/if}}
}

// configureWunderGraphHooks configures the WunderGraph hooks without injecting an internal client
// more info on how to use hooks can be found here: https://wundergraph.com/docs/overview/features/typesafe_hooks
// hooks reference docs: https://wundergraph.com/docs/reference/wundergraph_config_ts/overview
export const configureWunderGraphHooks = (config: HooksConfig) => {
    const hooksConfig: HooksConfiguration = {
        queries: config.queries as { [name: string]: {preResolve: any,postResolve:any,mutatingPostResolve: any} },
        mutations: config.mutations as { [name: string]: {preResolve: any,postResolve:any,mutatingPostResolve: any} },
        authentication: config.authentication as { postAuthentication?: any, mutatingPostAuthentication?: any, revalidate?: any }
    }
    const server = {
        config: hooksConfig,
        start() {
            const fastify = Fastify({
                logger: true
            })

            fastify.addHook<{ Body: { user: User } }>("preHandler", async (req, reply) => {
                req.ctx = {
                    user: req.body.user,
                }
            });

            // authentication
            fastify.post('/authentication/postAuthentication', async (request, reply) => {
                reply.type('application/json').code(200)
                if (config.authentication?.postAuthentication !== undefined && request.ctx.user !== undefined){
                    try {
                        await config.authentication.postAuthentication(request.ctx.user);
                    } catch (err){
                        request.log.error(err);
                        reply.code(500);
                        return {hook: "postAuthentication", error: err};
                    }
                }
                return {
                    hook: "postAuthentication"
                }
            })
            fastify.post('/authentication/mutatingPostAuthentication', async (request, reply) => {
                reply.type('application/json').code(200)
                if (config.authentication?.mutatingPostAuthentication !== undefined && request.ctx.user !== undefined){
                    try {
                        const out = await config.authentication.mutatingPostAuthentication(request.ctx.user);
                        return {
                            hook: "mutatingPostAuthentication",
                            response: out,
                        }
                    } catch (err) {
                        request.log.error(err);
                        reply.code(500);
                        return {hook: "mutatingPostAuthentication", error: err};
                    }
                }
            })
            fastify.post('/authentication/revalidateAuthentication', async (request, reply) => {
                reply.type('application/json').code(200)
                if (config.authentication?.revalidate !== undefined && request.ctx.user !== undefined){
                    try {
                        const out = await config.authentication.revalidate(request.ctx.user);
                        return {
                            hook: "revalidateAuthentication",
                            response: out,
                        }
                    } catch (err) {
                        request.log.error(err);
                        reply.code(500);
                        return {hook: "revalidateAuthentication", error: err};
                    }
                }
            })

            {{#if hasQueries}}
            /**
            * Queries
            */
            {{#each queries}}

            // mock
            fastify.post{{#if hasInternalInput}}<{ Body: { input: Injected{{operationName}}Input } }>{{/if}}('/operation/{{operationName}}/mockResolve', async (request, reply) => {
                reply.type('application/json').code(200)
                try {
                    const mutated = await config?.queries?.{{operationName}}?.mockResolve?.(request.ctx{{#if hasInternalInput}}, request.body.input{{/if}})
                    return { op: '{{operationName}}', hook: 'mock', response: mutated }
                } catch (err) {
                    request.log.error(err);
                    reply.code(500)
                    return { op: '{{operationName}}', hook: 'mock', error: err }
                }
            })

            // preResolve
            fastify.post{{#if hasInternalInput}}<{ Body: { input: Injected{{operationName}}Input } }>{{/if}}('/operation/{{operationName}}/preResolve', async (request, reply) => {
                reply.type('application/json').code(200)
                try {
                    await config?.queries?.{{operationName}}?.preResolve?.(request.ctx{{#if hasInternalInput}}, request.body.input{{/if}})
                    return { op: '{{operationName}}', hook: 'preResolve' }
                } catch (err) {
                    request.log.error(err);
                    reply.code(500)
                    return { op: '{{operationName}}', hook: 'preResolve', error: err }
                }
            })
            // postResolve
                fastify.post<{ Body: { {{#if hasInternalInput}}input: Injected{{operationName}}Input,{{/if}} response: {{operationName}}Response } }>('/operation/{{operationName}}/postResolve', async (request, reply) => {
                reply.type('application/json').code(200)
                try {
                    await config?.queries?.{{operationName}}?.postResolve?.(request.ctx{{#if hasInternalInput}}, request.body.input{{/if}}, request.body.response)
                    return { op: '{{operationName}}', hook: 'postResolve' }
                } catch (err) {
                    request.log.error(err);
                    reply.code(500)
                    return { op: '{{operationName}}', hook: 'postResolve', error: err }
                }
            }){{#if hasInternalInput}}
            // mutatingPreResolve
            fastify.post<{ Body: { {{#if hasInternalInput}}input: Injected{{operationName}}Input{{/if}} } }>('/operation/{{operationName}}/mutatingPreResolve', async (request, reply) => {
                reply.type("application/json").code(200);
                try {
                    const mutated = await config?.queries?.{{operationName}}?.mutatingPreResolve?.(request.ctx,{{#if hasInternalInput}}request.body.input{{/if}});
                    return {op: '{{operationName}}', hook: "mutatingPreResolve", input: mutated};
                } catch (err) {
                    request.log.error(err);
                    reply.code(500);
                    return {op: '{{operationName}}', hook: 'mutatingPreResolve', error: err};
                }
            });{{/if}}
            // mutatingPostResolve
            fastify.post<{ Body: { {{#if hasInternalInput}}input: Injected{{operationName}}Input,{{/if}}response: {{operationName}}Response } }>('/operation/{{operationName}}/mutatingPostResolve', async (request, reply) => {
                reply.type("application/json").code(200);
                try {
                    const mutated = await config?.queries?.{{operationName}}?.mutatingPostResolve?.(request.ctx,{{#if hasInternalInput}}request.body.input,{{/if}} request.body.response);
                    return {op: '{{operationName}}', hook: "mutatingPostResolve", response: mutated};
                } catch (err) {
                    request.log.error(err);
                    reply.code(500);
                    return {op: '{{operationName}}', hook: 'mutatingPostResolve', error: err};
                }
            });
            {{/each}}
            {{/if}}

            {{#if hasMutations}}
            /**
            * Mutations
            */
            {{#each mutations}}

            // mock
            fastify.post{{#if hasInternalInput}}<{ Body: { input: Injected{{operationName}}Input } }>{{/if}}('/operation/{{operationName}}/mockResolve', async (request, reply) => {
                reply.type('application/json').code(200)
                try {
                    const mutated = await config?.mutations?.{{operationName}}?.mockResolve?.(request.ctx{{#if hasInternalInput}}, request.body.input{{/if}})
                    return { op: '{{operationName}}', hook: 'mock', response: mutated }
                } catch (err) {
                    request.log.error(err);
                    reply.code(500)
                    return { op: '{{operationName}}', hook: 'mock', error: err }
                }
            })

            // preResolve
            fastify.post{{#if hasInternalInput}}<{ Body: { input: Injected{{operationName}}Input } }>{{/if}}('/operation/{{operationName}}/preResolve', async (request, reply) => {
                reply.type('application/json').code(200)
                try {
                    await config?.mutations?.{{operationName}}?.preResolve?.(request.ctx{{#if hasInternalInput}}, request.body.input{{/if}})
                    return { op: '{{operationName}}', hook: 'preResolve' }
                } catch (err) {
                    request.log.error(err);
                    reply.code(500)
                    return { op: '{{operationName}}', hook: 'preResolve', error: err }
                }
            })
            // postResolve
            fastify.post<{ Body: { {{#if hasInternalInput}}input: Injected{{operationName}}Input,{{/if}} response: {{operationName}}Response } }>('/operation/{{operationName}}/postResolve', async (request, reply) => {
                reply.type('application/json').code(200)
                try {
                    await config?.mutations?.{{operationName}}?.postResolve?.(request.ctx{{#if hasInternalInput}}, request.body.input{{/if}}, request.body.response)
                    return { op: '{{operationName}}', hook: 'postResolve' }
                } catch (err) {
                    request.log.error(err);
                    reply.code(500)
                    return { op: '{{operationName}}', hook: 'postResolve', error: err }
                }
            }){{#if hasInternalInput}}
            // mutatingPreResolve
            fastify.post<{ Body: { {{#if hasInternalInput}}input: Injected{{operationName}}Input{{/if}} } }>('/operation/{{operationName}}/mutatingPreResolve', async (request, reply) => {
                reply.type("application/json").code(200);
                try {
                    const mutated = await config?.mutations?.{{operationName}}?.mutatingPreResolve?.(request.ctx,{{#if hasInternalInput}}request.body.input{{/if}});
                    return {op: '{{operationName}}', hook: "mutatingPreResolve", input: mutated};
                } catch (err) {
                    request.log.error(err);
                    reply.code(500);
                    return {op: '{{operationName}}', hook: 'mutatingPreResolve', error: err};
                }
            });{{/if}}
            // mutatingPostResolve
            fastify.post<{ Body: { {{#if hasInternalInput}}input: Injected{{operationName}}Input,{{/if}}response: {{operationName}}Response } }>('/operation/{{operationName}}/mutatingPostResolve', async (request, reply) => {
                reply.type("application/json").code(200);
                try {
                    const mutated = await config?.mutations?.{{operationName}}?.mutatingPostResolve?.(request.ctx,{{#if hasInternalInput}}request.body.input,{{/if}} request.body.response);
                    return {op: '{{operationName}}', hook: "mutatingPostResolve", response: mutated};
                } catch (err) {
                    request.log.error(err);
                    reply.code(500);
                    return {op: '{{operationName}}', hook: 'mutatingPostResolve', error: err};
                }
            });
            {{/each}}
            {{/if}}

            fastify.listen({{serverPort}}, (err, address) => {
                if (err) {
                    console.error(err)
                    process.exit(0)
                }
                console.log(`hooks server listening at ${address}`)
            })
        }
    }

    if (process.env.START_HOOKS_SERVER === 'true') {
        server.start()
    }

    return server
}